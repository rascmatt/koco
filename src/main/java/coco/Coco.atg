/*-------------------------------------------------------------------------
Coco.ATG -- Attributed Grammar
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by W. Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2, or (at your option) any
later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
/*-------------------------------------------------------------------------
 compile with:
   javac Coco.Coco Coco.ATG -package Coco
-------------------------------------------------------------------------*/

$package=coco

COMPILER Coco

	val id = 0
	val str = 1
	
	lateinit var trace: Trace          // other Coco objects referenced by this ATG
	lateinit var tab: Tab
	lateinit var dfa: DFA
	lateinit var pgen: ParserGen

	var genScanner = false
	var tokenString: String? = null   // used in declarations of literal tokens
	var noString = "-none-"           // used in declarations of literal tokens

/*-------------------------------------------------------------------------*/

CHARACTERS
  letter    = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
  digit     = "0123456789".
  cr        = '\r'.
  lf        = '\n'.
  tab       = '\t'.
  stringCh  = ANY - '"' - '\\' - cr - lf.
  charCh    = ANY - '\'' - '\\' - cr - lf.
  printable = '\u0020' .. '\u007e'.
  hex       = "0123456789abcdef".

TOKENS
  ident     = letter { letter | digit }.
  number    = digit { digit }.
  string    = '"' { stringCh | '\\' printable } '"'.
  badString = '"' { stringCh | '\\' printable } (cr | lf).
  char      = '\'' ( charCh | '\\' printable { hex } ) '\''.

PRAGMAS
  ddtSym    = '$' { digit | letter }.    (. tab.SetDDT(la.`val`) .)
  optionSym = '$' letter { letter } '='
              { digit | letter
              | '-' | '.' | ':'
              }.                         (. tab.SetOption(la.`val`) .)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco                            (. var sym: Symbol?; var g: Graph; var g1: Graph; var g2: Graph; var gramName: String; var s: CharSet; var beg: Int; .)
=
  [ // import statements
    ANY                          (. beg = t.pos .)
    { ANY }                      (. pgen.usingPos = Position(beg, la.pos, 0); .)
  ]

  "COMPILER"                    (. genScanner = true
                                   tab.ignored = CharSet() .)
  ident                         (. gramName = t.`val`
                                   beg = la.pos
                                 .)
  { ANY }                       (. tab.semDeclPos = Position(beg, la.pos, 0) .)
  [ "IGNORECASE"                (. dfa.ignoreCase = true .) ]   /* pdt */
  [ "CHARACTERS" { SetDecl }]
  [ "TOKENS"  { TokenDecl<Node.t> }]
  [ "PRAGMAS" { TokenDecl<Node.pr> }]
  { "COMMENTS"                  (. var nested = false .)
    "FROM" TokenExpr<out g1>
    "TO" TokenExpr<out g2>
    [ "NESTED"                  (. nested = true .)
    ]                           (. dfa.NewComment(g1.l, g2.l, nested) .)
  }
  { "IGNORE" Set<out s>         (. tab.ignored.Or(s) .)
  }

  SYNC
  "PRODUCTIONS"                 (. if (genScanner) dfa.MakeDeterministic()
                                   tab.DeleteNodes()
                                 .)
  { ident                       (. sym = tab.FindSym(t.`val`)
                                   val undef = sym == null
                                   if (undef) sym = tab.NewSym(Node.nt, t.`val`, t.line)
                                   else {
                                     if (sym.typ == Node.nt) {
                                       if (sym.graph != null) SemErr("name declared twice")
                                     } else SemErr("this symbol kind not allowed on left side of production")
                                     sym.line = t.line
                                   }
                                   val noAttrs = sym.attrPos == null
                                   sym.attrPos = null
                                   val noRet = sym.retVar == null
                                   sym.retVar = null
                                   sym?.let {
                                 .)
    [ AttrDecl<sym> ]           (. }
                                   if (!undef)
                                     if (noAttrs != (sym.attrPos == null)
                                       || noRet != (sym.retVar == null))
                                       SemErr("attribute mismatch between declaration and use of this symbol")
                                 .)
    [ SemText<out sym.semPos> ]
    WEAK '='
    Expression<out g>           (. sym.graph = g.l
                                   tab.Finish(g)
                                 .)
    WEAK '.'
  }
  "END" ident                   (. if (gramName.compareTo(t.`val`) != 0)
                                     SemErr("name does not match grammar name")
                                   tab.gramSy = tab.FindSym(gramName)
                                   if (tab.gramSy == null)
                                     SemErr("missing production for grammar name")
                                   else {
                                     sym = tab.gramSy
                                     if (sym.attrPos != null)
                                       SemErr("grammar symbol must not have attributes")
                                   }
                                   tab.noSym = tab.NewSym(Node.t, "???", 0) // noSym gets highest number
                                   tab.SetupAnys()
                                   tab.RenumberPragmas()
                                   if (tab.ddt[2]) tab.PrintNodes()
                                   if (errors.count == 0) {
                                     println("checking")
                                     tab.CompSymbolSets();
                                     if (tab.ddt[7]) tab.XRef()
                                     if (tab.GrammarOk()) {
                                       print("parser")
                                       pgen.WriteParser()
                                       if (genScanner) {
                                         print(" + scanner")
                                         dfa.WriteScanner();
                                         if (tab.ddt[0]) dfa.PrintStates()
                                       }
                                       println(" generated")
                                       if (tab.ddt[8]) pgen.WriteStatistics()
                                     }
                                   }
                                   if (tab.ddt[6]) tab.PrintSymbolTable()
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

SetDecl                         (. var s: CharSet .)
=
  ident                         (. val name = t.`val`;
                                   var c: CharClass? = tab.FindCharClass(name)
                                   if (c != null) SemErr("name declared twice")
                                 .)
  '=' Set<out s>                (. if (s.Elements() == 0) SemErr("character set must not be empty")
                                   c = tab.NewCharClass(name, s)
                                 .)
  '.'
.

/*------------------------------------------------------------------------------------*/

Set<out CharSet s>              (. var s2: CharSet .)
=
  SimSet<out s>
  { '+' SimSet<out s2>          (. s.Or(s2) .)
  | '-' SimSet<out s2>          (. s.Subtract(s2) .)
  }
.

/*------------------------------------------------------------------------------------*/

SimSet<out CharSet s>           (. var n1: Int; var n2: Int .)
=                               (. s = CharSet(); .)
( ident                         (. val c: CharClass? = tab.FindCharClass(t.`val`)
                                   if (c == null) SemErr("undefined name"); else s.Or(c.set)
                                 .)
| string                        (. var name: String = t.`val`
                                   name = tab.Unescape(name.substring(1, name.length-1))
                                   for (i in 0 until name.length)
                                     if (dfa.ignoreCase) s.Set(Character.toLowerCase(name[i]).code)
                                     else s.Set(name[i].code) .)
| Char<out n1>                  (. s.Set(n1) .)
  [ ".." Char<out n2>           (. for (i in n1..n2) s.Set(i) .)
  ]
| "ANY"                         (. s = CharSet(); s.Fill() .)
)
.

/*--------------------------------------------------------------------------------------*/

Char<out Int n>
=
  char                          (. var name = t.`val`; n = 0
                                   name = tab.Unescape(name.substring(1, name.length-1))
                                   if (name.length == 1) n = name[0].code;
                                   else SemErr("unacceptable character value")
                                   if (dfa.ignoreCase && n.toChar() >= 'A' && n.toChar() <= 'Z') n += 32;
                                 .)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<typ: Int>              (. var s: SymInfo; var sym: Symbol?; var g: Graph; .)
=
  Sym<out s>                    (. sym = tab.FindSym(s.name);
                                   if (sym != null) SemErr("name declared twice")
                                   else {
                                     sym = tab.NewSym(typ, s.name, t.line)
                                     sym.tokenKind = Symbol.fixedToken
                                   }
                                   tokenString = null
                                 .)
  SYNC
  ( '=' TokenExpr<out g> '.'    (. if (s.kind == str) SemErr("a literal must not be declared with a structure")
                                   tab.Finish(g)
                                   if (tokenString == null || tokenString.equals(noString))
                                     dfa.ConvertToStates(g.l, sym)
                                   else { // TokenExpr is a single string
                                     if (tab.literals.get(tokenString) != null)
                                       SemErr("token string declared twice")
                                     tab.literals[tokenString] = sym
                                     dfa.MatchLiteral(tokenString, sym)
                                   }
                                 .)
  |                             (. if (s.kind == id) genScanner = false
                                   else dfa.MatchLiteral(sym.name, sym)
                                 .)
  )
  [ SemText<out sym.semPos>     (. if (typ != Node.pr) SemErr("semantic action not allowed here") .)
  ]
.

/*------------------------------------------------------------------------------------*/

AttrDecl<sym: Symbol>            (. var beg: Int; var col: Int .)
= 
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")               (. beg = la.pos .)
    TypeName                    (. sym.retType = scanner.buffer.GetString(beg, la.pos) .)
    ident                       (. sym.retVar = t.`val` .)
    ( '>'
    | ','                       (. beg = la.pos; col = la.col .)
      { ANY } '>'               (. if (t.pos > beg)
                                     sym.attrPos = Position(beg, t.pos, col) .)
    )
  |                             (. beg = la.pos; col = la.col .)
    [ ANY { ANY } ] '>'         (. if (t.pos > beg)
                                     sym.attrPos = Position(beg, t.pos, col) .)
  )
|
  "<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")               (. beg = la.pos .)
    TypeName                    (. sym.retType = scanner.buffer.GetString(beg, la.pos) .)
    ident                       (. sym.retVar = t.`val` .)
    ( ".>"
    | ','                       (. beg = la.pos; col = la.col .)
      { ANY } ".>"              (. if (t.pos > beg)
                                     sym.attrPos = Position(beg, t.pos, col) .)
    )
  |                             (. beg = la.pos; col = la.col .)
    [ ANY { ANY } ] ".>"        (. if (t.pos > beg)
                                     sym.attrPos = Position(beg, t.pos, col) .)
  ).

/*------------------------------------------------------------------------------------*/
// type names may contain angle brackets for generics, or ? for kotlin's nullable types
TypeName
= ident { '.' ident | '[' ']' | '<' TypeName {',' TypeName} '>'} [ '?' ].

/*------------------------------------------------------------------------------------*/

Expression<out Graph g>         (. var g2: Graph; .)
=
  Term<out g>                   (. var first = true; .)
  { WEAK '|'
    Term<out g2>                (. if (first) { tab.MakeFirstAlt(g); first = false }
                                   tab.MakeAlternative(g, g2)
                                 .)
  }
.

/*------------------------------------------------------------------------------------*/

Term<out Graph result>          (. var g: Graph? = null; var g2: Graph; var rslv: Node? = null        .)
=
( [                             (. rslv = tab.NewNode(Node.rslv, null, la.line) .)
    Resolver<out rslv.pos>      (. g = Graph(rslv)                              .)
  ]
  Factor<out g2>                (. if (rslv != null) tab.MakeSequence(g, g2)
                                   else g = g2
                                 .)
  { Factor<out g2>              (. tab.MakeSequence(g, g2) .)
  }
|                               (. g = Graph(tab.NewNode(Node.eps, null, 0))    .)
)                               (. result = g ?: Graph(tab.NewNode(Node.eps, null, 0)) // invalid start of Term
                                 .)
.

/*------------------------------------------------------------------------------------*/

Factor<out Graph result>        (. var s: SymInfo; var pos: Position; var weak = false;
                                   var g: Graph? = null; .)
=
( [ "WEAK"                      (. weak = true .)
  ]
  Sym<out s>                    (. var sym: Symbol? = tab.FindSym(s.name)
                                   if (sym == null && s.kind == str)
                                     sym = tab.literals[s.name]?.let { it as Symbol }
                                   val undef = sym == null
                                   if (undef) {
                                     if (s.kind == id)
                                       sym = tab.NewSym(Node.nt, s.name, 0)  // forward nt
                                     else if (genScanner) {
                                       sym = tab.NewSym(Node.t, s.name, t.line)
                                       dfa.MatchLiteral(sym.name, sym)
                                     } else {  // undefined string in production
                                       SemErr("undefined string in production")
                                       sym = tab.eofSy  // dummy
                                     }
                                   }
                                   var typ = sym.typ
                                   if (typ != Node.t && typ != Node.nt)
                                     SemErr("this symbol kind is not allowed in a production")
                                   if (weak)
                                     if (typ == Node.t) typ = Node.wt
                                     else SemErr("only terminals may be weak")
                                   val p = tab.NewNode(typ, sym, t.line)
                                   g = Graph(p)
                                 .)
  [ Attribs<p>                  (. if (s.kind != id) SemErr("a literal must not have attributes"); .)
  ]                             (. if (undef) {
                                     sym.attrPos = p.pos;  // dummy
                                     sym.retVar = p.retVar;  // AH - dummy
                                   } else if ((p.pos == null) != (sym.attrPos == null)
                                          || (p.retVar == null) != (sym.retVar == null))
                                     SemErr("attribute mismatch between declaration and use of this symbol");
                                 .)
| '(' Expression<out g> ')'
| '[' Expression<out g> ']'     (. tab.MakeOption(g) .)
| '{' Expression<out g> '}'     (. tab.MakeIteration(g) .)
| SemText<out pos>              (. val p = tab.NewNode(Node.sem, null, 0)
                                   p.pos = pos
                                   g = Graph(p)
                                 .)
| "ANY"                         (. val p = tab.NewNode(Node.any, null, t.line)  // p.set is set in tab.SetupAnys
                                   g = Graph(p)
                                 .)
| "SYNC"                        (. val p = tab.NewNode(Node.sync, null, 0)
                                   g = Graph(p)
                                 .)
)                               (.   // invalid start of Factor
                                     result = g ?: Graph(tab.NewNode(Node.eps, null, 0))
                                 .)
.

/*------------------------------------------------------------------------------------*/

Resolver<out Position pos>
=
  "IF" "("                      (. val beg = la.pos; val col = la.col .)
  Condition                     (. pos = Position(beg, t.pos, col) .)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<out Graph g>          (. var g2: Graph .)
=
  TokenTerm<out g>              (. var first = true; .)
  { WEAK '|'
    TokenTerm<out g2>           (. if (first) { tab.MakeFirstAlt(g); first = false }
                                   tab.MakeAlternative(g, g2)
                                .)
  }
.

/*------------------------------------------------------------------------------------*/

TokenTerm<out Graph g>          (. var g2: Graph .)
=
  TokenFactor<out g>
  { TokenFactor<out g2>         (. tab.MakeSequence(g, g2) .)
  }
  [ "CONTEXT"
    '(' TokenExpr<out g2>       (. tab.SetContextTrans(g2.l); dfa.hasCtxMoves = true
                                   tab.MakeSequence(g, g2) .)
    ')'
  ]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<out Graph result>   (. var s: SymInfo .)
=
                                (. var g: Graph? = null .)
( Sym<out s>                    (. if (s.kind == id) {
                                     var c = tab.FindCharClass(s.name)
                                     if (c == null) {
                                       SemErr("undefined name")
                                       c = tab.NewCharClass(s.name, CharSet())
                                     }
                                     val p = tab.NewNode(Node.clas, null, 0); p.`val` = c.n
                                     g = Graph(p)
                                     tokenString = noString
                                   } else { // str
                                     g = tab.StrToGraph(s.name)
                                     if (tokenString == null) tokenString = s.name
                                     else tokenString = noString
                                   }
                                 .)
| '(' TokenExpr<out g> ')'
| '[' TokenExpr<out g> ']'      (. tab.MakeOption(g); tokenString = noString .)
| '{' TokenExpr<out g> '}'      (. tab.MakeIteration(g); tokenString = noString .)
)                               (. result = g ?: Graph(tab.NewNode(Node.eps, null, 0)); // invalid start of TokenFactor
                                .)
.

/*------------------------------------------------------------------------------------*/

Sym<out SymInfo s>
=                               (. s = SymInfo(); s.name = "???"; s.kind = id .)
( ident                         (. s.kind = id; s.name = t.`val` .)
| (string                       (. s.name = t.`val` .)
  | char                        (. s.name = "\"" + t.`val`.substring(1, t.`val`.length-1) + "\"" .)
  )                             (. s.kind = str
                                   if (dfa.ignoreCase) s.name = s.name.lowercase()
                                   if (s.name.indexOf(' ') >= 0)
                                     SemErr("literal tokens must not contain blanks") .)
)
.

/*------------------------------------------------------------------------------------*/

Attribs<n: Node>                 (. var beg: Int; var col: Int .)
=
  '<'                           // attributes denoted by < ... >
  ( ('^' | "out")               (. beg = la.pos .)
    { ANY
    | Bracketed
    | badString                 (. SemErr("bad string in attributes") .)
    }                           (. n.retVar = scanner.buffer.GetString(beg, la.pos) .)
    ( '>'
    | ','                       (. beg = la.pos; col = la.col .)
      {  ANY
       | badString              (. SemErr("bad string in attributes") .)
      } '>'                     (. if (t.pos > beg) n.pos = Position(beg, t.pos, col) .)
    )
  |                             (. beg = la.pos; col = la.col .)
    [ ( ANY
	  | badString               (. SemErr("bad string in attributes") .)
	  )
      {  ANY
      | badString               (. SemErr("bad string in attributes") .)
      }
    ] '>'                       (. if (t.pos > beg) n.pos = Position(beg, t.pos, col) .)
  )
|
	"<."                          // attributes denoted by <. ... .>
  ( ('^' | "out")               (. beg = la.pos .)
    { ANY
    | Bracketed
    | badString                 (. SemErr("bad string in attributes") .)
    }                           (. n.retVar = scanner.buffer.GetString(beg, la.pos) .)
    ( ".>"
    | ','                       (. beg = la.pos; col = la.col .)
      {  ANY
       | badString              (. SemErr("bad string in attributes") .)
      } ".>"                    (. if (t.pos > beg) n.pos = Position(beg, t.pos, col) .)
    )
  |                             (. beg = la.pos; col = la.col .)
    [ ( ANY
	  | badString               (. SemErr("bad string in attributes") .)
	  )
      {  ANY
      | badString               (. SemErr("bad string in attributes") .)
      }
    ] ".>"                      (. if (t.pos > beg) n.pos = Position(beg, t.pos, col) .)
  )
.

/*------------------------------------------------------------------------------------*/
// skip commas in brackets such as in <out a[i, j], b> or <out a[foo(x, y)], z>
Bracketed
= '(' {Bracketed | ANY} ')' | '[' {Bracketed | ANY} ']'.

/*------------------------------------------------------------------------------------*/

SemText<out Position pos>
=
  "(."                          (. val beg = la.pos; val col = la.col .)
  { ANY
  | badString                   (. SemErr("bad string in semantic action") .)
  | "(."                        (. SemErr("missing end of previous semantic action") .)
  }
  ".)"                          (. pos = Position(beg, t.pos, col) .)
.

END Coco.
