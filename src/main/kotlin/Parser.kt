/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
package coco


class Parser(var scanner: Scanner) {

    companion object {

		const val _EOF = 0;
		const val _ident = 1;
		const val _number = 2;
		const val _string = 3;
		const val _badString = 4;
		const val _char = 5;
		const val maxT = 44
		const val _ddtSym = 45;
		const val _optionSym = 46;


        const val _T = true;
        const val _x = false;
        const val minErrDist = 2;
    }

    val id = 0
	val str = 1
	
	lateinit var trace: Trace          // other Coco objects referenced by this ATG
	lateinit var tab: Tab
	lateinit var dfa: DFA
	lateinit var pgen: ParserGen

	var genScanner = false
	var tokenString: String? = null   // used in declarations of literal tokens
	var noString = "-none-"           // used in declarations of literal tokens

/*-------------------------------------------------------------------------*/



	private lateinit var t: Token    // last recognized token
	private lateinit var la: Token   // lookahead token
	var errDist = minErrDist

	val errors: Errors = Errors()

	private fun SynErr (n: Int) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n)
		errDist = 0
	}

	fun SemErr (msg: String) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg)
		errDist = 0
	}
	
	private fun Get () {
		while (true) {
			t = la
			la = scanner.Scan()
			if (la.kind <= maxT) {
				++errDist
				break
			}

			if (la.kind == 45) {
				tab.SetDDT(la.`val`) 
			}
			if (la.kind == 46) {
				tab.SetOption(la.`val`) 
			}
			la = t
		}
	}
	
	private fun Expect (n: Int) {
		if (la.kind==n) Get() else { SynErr(n) }
	}
	
	private fun StartOf (s: Int): Boolean {
		return set[s][la.kind]
	}
	
	private fun ExpectWeak (n: Int, follow: Int) {
		if (la.kind == n) Get()
		else {
			SynErr(n)
			while (!StartOf(follow)) Get()
		}
	}
	
	private fun WeakSeparator (n: Int, syFol: Int, repFol: Int): Boolean {
		var kind = la.kind
		if (kind == n) { Get(); return true }
		else if (StartOf(repFol)) return false
		else {
			SynErr(n)
			while (!(set[syFol][kind] || set[repFol][kind] || set[0][kind])) {
				Get()
				kind = la.kind
			}
			return StartOf(syFol)
		}
	}
	
	private fun Coco() {
		var sym: Symbol?; var g: Graph; var g1: Graph; var g2: Graph; var gramName: String; var s: CharSet; var beg: Int; 
		if (StartOf(1)) {
			Get()
			beg = t.pos 
			while (StartOf(1)) {
				Get()
			}
			pgen.usingPos = Position(beg, la.pos, 0); 
		}
		Expect(6)
		genScanner = true
		tab.ignored = CharSet() 
		Expect(1)
		gramName = t.`val`
		beg = la.pos
		
		while (StartOf(2)) {
			Get()
		}
		tab.semDeclPos = Position(beg, la.pos, 0) 
		if (la.kind == 7) {
			Get()
			dfa.ignoreCase = true 
		}
		if (la.kind == 8) {
			Get()
			while (la.kind == 1) {
				SetDecl()
			}
		}
		if (la.kind == 9) {
			Get()
			while (la.kind == 1 || la.kind == 3 || la.kind == 5) {
				TokenDecl(Node.t)
			}
		}
		if (la.kind == 10) {
			Get()
			while (la.kind == 1 || la.kind == 3 || la.kind == 5) {
				TokenDecl(Node.pr)
			}
		}
		while (la.kind == 11) {
			Get()
			var nested = false 
			Expect(12)
			g1 = TokenExpr()
			Expect(13)
			g2 = TokenExpr()
			if (la.kind == 14) {
				Get()
				nested = true 
			}
			dfa.NewComment(g1.l, g2.l, nested) 
		}
		while (la.kind == 15) {
			Get()
			s = Set()
			tab.ignored.Or(s) 
		}
		while (!(la.kind == 0 || la.kind == 16)) {SynErr(45); Get();}
		Expect(16)
		if (genScanner) dfa.MakeDeterministic()
		tab.DeleteNodes()
		
		while (la.kind == 1) {
			Get()
			sym = tab.FindSym(t.`val`)
			val undef = sym == null
			if (undef) sym = tab.NewSym(Node.nt, t.`val`, t.line)
			else {
			 if (sym.typ == Node.nt) {
			   if (sym.graph != null) SemErr("name declared twice")
			 } else SemErr("this symbol kind not allowed on left side of production")
			 sym.line = t.line
			}
			val noAttrs = sym.attrPos == null
			sym.attrPos = null
			val noRet = sym.retVar == null
			sym.retVar = null
			sym?.let {
			
			if (la.kind == 24 || la.kind == 29) {
				AttrDecl(sym)
			}
			}
			if (!undef)
			 if (noAttrs != (sym.attrPos == null)
			   || noRet != (sym.retVar == null))
			   SemErr("attribute mismatch between declaration and use of this symbol")
			
			if (la.kind == 42) {
				sym.semPos = SemText()
			}
			ExpectWeak(17, 3)
			g = Expression()
			sym.graph = g.l
			tab.Finish(g)
			
			ExpectWeak(18, 4)
		}
		Expect(19)
		Expect(1)
		if (gramName.compareTo(t.`val`) != 0)
		 SemErr("name does not match grammar name")
		tab.gramSy = tab.FindSym(gramName)
		if (tab.gramSy == null)
		 SemErr("missing production for grammar name")
		else {
		 sym = tab.gramSy
		 if (sym.attrPos != null)
		   SemErr("grammar symbol must not have attributes")
		}
		tab.noSym = tab.NewSym(Node.t, "???", 0) // noSym gets highest number
		tab.SetupAnys()
		tab.RenumberPragmas()
		if (tab.ddt[2]) tab.PrintNodes()
		if (errors.count == 0) {
		 println("checking")
		 tab.CompSymbolSets();
		 if (tab.ddt[7]) tab.XRef()
		 if (tab.GrammarOk()) {
		   print("parser")
		   pgen.WriteParser()
		   if (genScanner) {
		     print(" + scanner")
		     dfa.WriteScanner();
		     if (tab.ddt[0]) dfa.PrintStates()
		   }
		   println(" generated")
		   if (tab.ddt[8]) pgen.WriteStatistics()
		 }
		}
		if (tab.ddt[6]) tab.PrintSymbolTable()
		
		Expect(18)
	}

	private fun SetDecl() {
		var s: CharSet 
		Expect(1)
		val name = t.`val`;
		var c: CharClass? = tab.FindCharClass(name)
		if (c != null) SemErr("name declared twice")
		
		Expect(17)
		s = Set()
		if (s.Elements() == 0) SemErr("character set must not be empty")
		c = tab.NewCharClass(name, s)
		
		Expect(18)
	}

	private fun TokenDecl(typ: Int) {
		var s: SymInfo; var sym: Symbol?; var g: Graph; 
		s = Sym()
		sym = tab.FindSym(s.name);
		if (sym != null) SemErr("name declared twice")
		else {
		 sym = tab.NewSym(typ, s.name, t.line)
		 sym.tokenKind = Symbol.fixedToken
		}
		tokenString = null
		
		while (!(StartOf(5))) {SynErr(46); Get();}
		if (la.kind == 17) {
			Get()
			g = TokenExpr()
			Expect(18)
			if (s.kind == str) SemErr("a literal must not be declared with a structure")
			tab.Finish(g)
			if (tokenString == null || tokenString.equals(noString))
			 dfa.ConvertToStates(g.l, sym)
			else { // TokenExpr is a single string
			 if (tab.literals.get(tokenString) != null)
			   SemErr("token string declared twice")
			 tab.literals[tokenString] = sym
			 dfa.MatchLiteral(tokenString, sym)
			}
			
		} else if (StartOf(6)) {
			if (s.kind == id) genScanner = false
			else dfa.MatchLiteral(sym.name, sym)
			
		} else SynErr(47)
		if (la.kind == 42) {
			sym.semPos = SemText()
			if (typ != Node.pr) SemErr("semantic action not allowed here") 
		}
	}

	private fun TokenExpr(): Graph  {
		var g: Graph 
		var g2: Graph 
		g = TokenTerm()
		var first = true; 
		while (WeakSeparator(33,7,8) ) {
			g2 = TokenTerm()
			if (first) { tab.MakeFirstAlt(g); first = false }
			tab.MakeAlternative(g, g2)
			
		}
		return g
	}

	private fun Set(): CharSet  {
		var s: CharSet 
		var s2: CharSet 
		s = SimSet()
		while (la.kind == 20 || la.kind == 21) {
			if (la.kind == 20) {
				Get()
				s2 = SimSet()
				s.Or(s2) 
			} else {
				Get()
				s2 = SimSet()
				s.Subtract(s2) 
			}
		}
		return s
	}

	private fun AttrDecl(sym: Symbol) {
		var beg: Int; var col: Int 
		if (la.kind == 24) {
			Get()
			if (la.kind == 25 || la.kind == 26) {
				if (la.kind == 25) {
					Get()
				} else {
					Get()
				}
				beg = la.pos 
				TypeName()
				sym.retType = scanner.buffer.GetString(beg, la.pos) 
				Expect(1)
				sym.retVar = t.`val` 
				if (la.kind == 27) {
					Get()
				} else if (la.kind == 28) {
					Get()
					beg = la.pos; col = la.col 
					while (StartOf(9)) {
						Get()
					}
					Expect(27)
					if (t.pos > beg)
					 sym.attrPos = Position(beg, t.pos, col) 
				} else SynErr(48)
			} else if (StartOf(10)) {
				beg = la.pos; col = la.col 
				if (StartOf(11)) {
					Get()
					while (StartOf(9)) {
						Get()
					}
				}
				Expect(27)
				if (t.pos > beg)
				 sym.attrPos = Position(beg, t.pos, col) 
			} else SynErr(49)
		} else if (la.kind == 29) {
			Get()
			if (la.kind == 25 || la.kind == 26) {
				if (la.kind == 25) {
					Get()
				} else {
					Get()
				}
				beg = la.pos 
				TypeName()
				sym.retType = scanner.buffer.GetString(beg, la.pos) 
				Expect(1)
				sym.retVar = t.`val` 
				if (la.kind == 30) {
					Get()
				} else if (la.kind == 28) {
					Get()
					beg = la.pos; col = la.col 
					while (StartOf(12)) {
						Get()
					}
					Expect(30)
					if (t.pos > beg)
					 sym.attrPos = Position(beg, t.pos, col) 
				} else SynErr(50)
			} else if (StartOf(10)) {
				beg = la.pos; col = la.col 
				if (StartOf(13)) {
					Get()
					while (StartOf(12)) {
						Get()
					}
				}
				Expect(30)
				if (t.pos > beg)
				 sym.attrPos = Position(beg, t.pos, col) 
			} else SynErr(51)
		} else SynErr(52)
	}

	private fun SemText(): Position  {
		var pos: Position 
		Expect(42)
		val beg = la.pos; val col = la.col 
		while (StartOf(14)) {
			if (StartOf(15)) {
				Get()
			} else if (la.kind == 4) {
				Get()
				SemErr("bad string in semantic action") 
			} else {
				Get()
				SemErr("missing end of previous semantic action") 
			}
		}
		Expect(43)
		pos = Position(beg, t.pos, col) 
		return pos
	}

	private fun Expression(): Graph  {
		var g: Graph 
		var g2: Graph; 
		g = Term()
		var first = true; 
		while (WeakSeparator(33,16,17) ) {
			g2 = Term()
			if (first) { tab.MakeFirstAlt(g); first = false }
			tab.MakeAlternative(g, g2)
			
		}
		return g
	}

	private fun SimSet(): CharSet  {
		var s: CharSet 
		var n1: Int; var n2: Int 
		s = CharSet(); 
		if (la.kind == 1) {
			Get()
			val c: CharClass? = tab.FindCharClass(t.`val`)
			if (c == null) SemErr("undefined name"); else s.Or(c.set)
			
		} else if (la.kind == 3) {
			Get()
			var name: String = t.`val`
			name = tab.Unescape(name.substring(1, name.length-1))
			for (i in 0 until name.length)
			 if (dfa.ignoreCase) s.Set(Character.toLowerCase(name[i]).code)
			 else s.Set(name[i].code) 
		} else if (la.kind == 5) {
			n1 = Char()
			s.Set(n1) 
			if (la.kind == 22) {
				Get()
				n2 = Char()
				for (i in n1..n2) s.Set(i) 
			}
		} else if (la.kind == 23) {
			Get()
			s = CharSet(); s.Fill() 
		} else SynErr(53)
		return s
	}

	private fun Char(): Int  {
		var n: Int 
		Expect(5)
		var name = t.`val`; n = 0
		name = tab.Unescape(name.substring(1, name.length-1))
		if (name.length == 1) n = name[0].code;
		else SemErr("unacceptable character value")
		if (dfa.ignoreCase && n.toChar() >= 'A' && n.toChar() <= 'Z') n += 32;
		
		return n
	}

	private fun Sym(): SymInfo  {
		var s: SymInfo 
		s = SymInfo(); s.name = "???"; s.kind = id 
		if (la.kind == 1) {
			Get()
			s.kind = id; s.name = t.`val` 
		} else if (la.kind == 3 || la.kind == 5) {
			if (la.kind == 3) {
				Get()
				s.name = t.`val` 
			} else {
				Get()
				s.name = "\"" + t.`val`.substring(1, t.`val`.length-1) + "\"" 
			}
			s.kind = str
			if (dfa.ignoreCase) s.name = s.name.lowercase()
			if (s.name.indexOf(' ') >= 0)
			 SemErr("literal tokens must not contain blanks") 
		} else SynErr(54)
		return s
	}

	private fun TypeName() {
		Expect(1)
		while (la.kind == 18 || la.kind == 24 || la.kind == 31) {
			if (la.kind == 18) {
				Get()
				Expect(1)
			} else if (la.kind == 31) {
				Get()
				Expect(32)
			} else {
				Get()
				TypeName()
				while (la.kind == 28) {
					Get()
					TypeName()
				}
				Expect(27)
			}
		}
	}

	private fun Term(): Graph  {
		var result: Graph 
		var g: Graph? = null; var g2: Graph; var rslv: Node? = null        
		if (StartOf(18)) {
			if (la.kind == 40) {
				rslv = tab.NewNode(Node.rslv, null, la.line) 
				rslv.pos = Resolver()
				g = Graph(rslv)                              
			}
			g2 = Factor()
			if (rslv != null) tab.MakeSequence(g, g2)
			else g = g2
			
			while (StartOf(19)) {
				g2 = Factor()
				tab.MakeSequence(g, g2) 
			}
		} else if (StartOf(20)) {
			g = Graph(tab.NewNode(Node.eps, null, 0))    
		} else SynErr(55)
		result = g ?: Graph(tab.NewNode(Node.eps, null, 0)) // invalid start of Term
		
		return result
	}

	private fun Resolver(): Position  {
		var pos: Position 
		Expect(40)
		Expect(35)
		val beg = la.pos; val col = la.col 
		Condition()
		pos = Position(beg, t.pos, col) 
		return pos
	}

	private fun Factor(): Graph  {
		var result: Graph 
		var s: SymInfo; var pos: Position; var weak = false;
		var g: Graph? = null; 
		when (la.kind) {
		1, 3, 5, 34 -> {
			if (la.kind == 34) {
				Get()
				weak = true 
			}
			s = Sym()
			var sym: Symbol? = tab.FindSym(s.name)
			if (sym == null && s.kind == str)
			 sym = tab.literals.get(s.name) as Symbol
			val undef = sym == null
			if (undef) {
			 if (s.kind == id)
			   sym = tab.NewSym(Node.nt, s.name, 0)  // forward nt
			 else if (genScanner) {
			   sym = tab.NewSym(Node.t, s.name, t.line)
			   dfa.MatchLiteral(sym.name, sym)
			 } else {  // undefined string in production
			   SemErr("undefined string in production")
			   sym = tab.eofSy  // dummy
			 }
			}
			var typ = sym.typ
			if (typ != Node.t && typ != Node.nt)
			 SemErr("this symbol kind is not allowed in a production")
			if (weak)
			 if (typ == Node.t) typ = Node.wt
			 else SemErr("only terminals may be weak")
			val p = tab.NewNode(typ, sym, t.line)
			g = Graph(p)
			
			if (la.kind == 24 || la.kind == 29) {
				Attribs(p)
				if (s.kind != id) SemErr("a literal must not have attributes"); 
			}
			if (undef) {
			 sym.attrPos = p.pos;  // dummy
			 sym.retVar = p.retVar;  // AH - dummy
			} else if ((p.pos == null) != (sym.attrPos == null)
			      || (p.retVar == null) != (sym.retVar == null))
			 SemErr("attribute mismatch between declaration and use of this symbol");
			
		}
		35 -> {
			Get()
			g = Expression()
			Expect(36)
		}
		31 -> {
			Get()
			g = Expression()
			Expect(32)
			tab.MakeOption(g) 
		}
		37 -> {
			Get()
			g = Expression()
			Expect(38)
			tab.MakeIteration(g) 
		}
		42 -> {
			pos = SemText()
			val p = tab.NewNode(Node.sem, null, 0)
			p.pos = pos
			g = Graph(p)
			
		}
		23 -> {
			Get()
			val p = tab.NewNode(Node.any, null, t.line)  // p.set is set in tab.SetupAnys
			g = Graph(p)
			
		}
		39 -> {
			Get()
			val p = tab.NewNode(Node.sync, null, 0)
			g = Graph(p)
			
		}
		else -> SynErr(56)
		}
		result = g ?: Graph(tab.NewNode(Node.eps, null, 0))
		
		return result
	}

	private fun Attribs(n: Node) {
		var beg: Int; var col: Int 
		if (la.kind == 24) {
			Get()
			if (la.kind == 25 || la.kind == 26) {
				if (la.kind == 25) {
					Get()
				} else {
					Get()
				}
				beg = la.pos 
				while (StartOf(21)) {
					if (StartOf(22)) {
						Get()
					} else if (la.kind == 31 || la.kind == 35) {
						Bracketed()
					} else {
						Get()
						SemErr("bad string in attributes") 
					}
				}
				n.retVar = scanner.buffer.GetString(beg, la.pos) 
				if (la.kind == 27) {
					Get()
				} else if (la.kind == 28) {
					Get()
					beg = la.pos; col = la.col 
					while (StartOf(9)) {
						if (StartOf(23)) {
							Get()
						} else {
							Get()
							SemErr("bad string in attributes") 
						}
					}
					Expect(27)
					if (t.pos > beg) n.pos = Position(beg, t.pos, col) 
				} else SynErr(57)
			} else if (StartOf(10)) {
				beg = la.pos; col = la.col 
				if (StartOf(11)) {
					if (StartOf(24)) {
						Get()
					} else {
						Get()
						SemErr("bad string in attributes") 
					}
					while (StartOf(9)) {
						if (StartOf(23)) {
							Get()
						} else {
							Get()
							SemErr("bad string in attributes") 
						}
					}
				}
				Expect(27)
				if (t.pos > beg) n.pos = Position(beg, t.pos, col) 
			} else SynErr(58)
		} else if (la.kind == 29) {
			Get()
			if (la.kind == 25 || la.kind == 26) {
				if (la.kind == 25) {
					Get()
				} else {
					Get()
				}
				beg = la.pos 
				while (StartOf(25)) {
					if (StartOf(26)) {
						Get()
					} else if (la.kind == 31 || la.kind == 35) {
						Bracketed()
					} else {
						Get()
						SemErr("bad string in attributes") 
					}
				}
				n.retVar = scanner.buffer.GetString(beg, la.pos) 
				if (la.kind == 30) {
					Get()
				} else if (la.kind == 28) {
					Get()
					beg = la.pos; col = la.col 
					while (StartOf(12)) {
						if (StartOf(27)) {
							Get()
						} else {
							Get()
							SemErr("bad string in attributes") 
						}
					}
					Expect(30)
					if (t.pos > beg) n.pos = Position(beg, t.pos, col) 
				} else SynErr(59)
			} else if (StartOf(10)) {
				beg = la.pos; col = la.col 
				if (StartOf(13)) {
					if (StartOf(28)) {
						Get()
					} else {
						Get()
						SemErr("bad string in attributes") 
					}
					while (StartOf(12)) {
						if (StartOf(27)) {
							Get()
						} else {
							Get()
							SemErr("bad string in attributes") 
						}
					}
				}
				Expect(30)
				if (t.pos > beg) n.pos = Position(beg, t.pos, col) 
			} else SynErr(60)
		} else SynErr(61)
	}

	private fun Condition() {
		while (StartOf(29)) {
			if (la.kind == 35) {
				Get()
				Condition()
			} else {
				Get()
			}
		}
		Expect(36)
	}

	private fun TokenTerm(): Graph  {
		var g: Graph 
		var g2: Graph 
		g = TokenFactor()
		while (StartOf(7)) {
			g2 = TokenFactor()
			tab.MakeSequence(g, g2) 
		}
		if (la.kind == 41) {
			Get()
			Expect(35)
			g2 = TokenExpr()
			tab.SetContextTrans(g2.l); dfa.hasCtxMoves = true
			tab.MakeSequence(g, g2) 
			Expect(36)
		}
		return g
	}

	private fun TokenFactor(): Graph  {
		var result: Graph 
		var s: SymInfo 
		var g: Graph? = null 
		if (la.kind == 1 || la.kind == 3 || la.kind == 5) {
			s = Sym()
			if (s.kind == id) {
			 var c = tab.FindCharClass(s.name)
			 if (c == null) {
			   SemErr("undefined name")
			   c = tab.NewCharClass(s.name, CharSet())
			 }
			 val p = tab.NewNode(Node.clas, null, 0); p.`val` = c.n
			 g = Graph(p)
			 tokenString = noString
			} else { // str
			 g = tab.StrToGraph(s.name)
			 if (tokenString == null) tokenString = s.name
			 else tokenString = noString
			}
			
		} else if (la.kind == 35) {
			Get()
			g = TokenExpr()
			Expect(36)
		} else if (la.kind == 31) {
			Get()
			g = TokenExpr()
			Expect(32)
			tab.MakeOption(g); tokenString = noString 
		} else if (la.kind == 37) {
			Get()
			g = TokenExpr()
			Expect(38)
			tab.MakeIteration(g); tokenString = noString 
		} else SynErr(62)
		result = g ?: Graph(tab.NewNode(Node.eps, null, 0)); // invalid start of TokenFactor
		
		return result
	}

	private fun Bracketed() {
		if (la.kind == 35) {
			Get()
			while (StartOf(29)) {
				if (la.kind == 31 || la.kind == 35) {
					Bracketed()
				} else {
					Get()
				}
			}
			Expect(36)
		} else if (la.kind == 31) {
			Get()
			while (StartOf(30)) {
				if (la.kind == 31 || la.kind == 35) {
					Bracketed()
				} else {
					Get()
				}
			}
			Expect(32)
		} else SynErr(63)
	}



	fun Parse() {
		la = Token()
		la.`val` = ""
		Get()
		Coco()
		Expect(0)

		scanner.buffer.Close()
	}

	val set: Array<Array<Boolean>> = arrayOf(
		arrayOf(_T,_T,_x,_T, _x,_T,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_x, _x,_x,_x,_x, _T,_T,_T,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_T,_T,_x,_T, _x,_T,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _T,_T,_T,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _x,_T,_T,_T, _x,_T,_x,_T, _T,_x,_T,_x, _x,_x),
		arrayOf(_T,_T,_x,_T, _x,_T,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _T,_T,_x,_T, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x),
		arrayOf(_T,_T,_x,_T, _x,_T,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _T,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x),
		arrayOf(_x,_T,_x,_T, _x,_T,_x,_x, _x,_x,_T,_T, _x,_x,_x,_T, _T,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x),
		arrayOf(_x,_T,_x,_T, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_T, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x),
		arrayOf(_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_T,_T,_T, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_T, _T,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_x, _T,_x),
		arrayOf(_x,_T,_x,_T, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_T,_x, _x,_x),
		arrayOf(_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_x,_x,_x, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x),
		arrayOf(_x,_T,_x,_T, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_T,_T, _x,_T,_x,_T, _T,_x,_T,_x, _x,_x),
		arrayOf(_x,_T,_x,_T, _x,_T,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_x,_x, _x,_x,_x,_T, _x,_x,_T,_T, _x,_T,_x,_T, _x,_x,_T,_x, _x,_x),
		arrayOf(_x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_T,_x, _x,_x,_x,_x, _x,_x,_x,_x, _x,_x,_x,_x, _T,_T,_x,_x, _T,_x,_T,_x, _x,_x,_x,_x, _x,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _x,_T,_T,_x, _T,_T,_T,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_x,_x, _T,_T,_T,_x, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x,_x,_T, _T,_T,_x,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_x),
		arrayOf(_x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _x,_T,_T,_T, _T,_T,_T,_T, _T,_T,_T,_T, _T,_x)

    )

} // end Parser


class Errors {
	var count = 0;                                  // number of errors detected
	val errorStream = System.out;                   // error messages go to this stream
	val errMsgFormat = "-- line {0} col {1}: {2}";  // 0=line, 1=column, 2=text
	
	protected fun printMsg(line: Int, column: Int, msg: String) {
		val b = StringBuffer(errMsgFormat)
		var pos = b.indexOf("{0}")
		if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, line) }
		pos = b.indexOf("{1}")
		if (pos >= 0) { b.delete(pos, pos+3); b.insert(pos, column) }
		pos = b.indexOf("{2}")
		if (pos >= 0) b.replace(pos, pos+3, msg)
		errorStream.println(b.toString())
	}
	
	fun SynErr (line: Int, col: Int, n: Int) {
		val s = when (n) {
		    
			0 -> "EOF expected"
			1 -> "ident expected"
			2 -> "number expected"
			3 -> "string expected"
			4 -> "badString expected"
			5 -> "char expected"
			6 -> "\"COMPILER\" expected"
			7 -> "\"IGNORECASE\" expected"
			8 -> "\"CHARACTERS\" expected"
			9 -> "\"TOKENS\" expected"
			10 -> "\"PRAGMAS\" expected"
			11 -> "\"COMMENTS\" expected"
			12 -> "\"FROM\" expected"
			13 -> "\"TO\" expected"
			14 -> "\"NESTED\" expected"
			15 -> "\"IGNORE\" expected"
			16 -> "\"PRODUCTIONS\" expected"
			17 -> "\"=\" expected"
			18 -> "\".\" expected"
			19 -> "\"END\" expected"
			20 -> "\"+\" expected"
			21 -> "\"-\" expected"
			22 -> "\"..\" expected"
			23 -> "\"ANY\" expected"
			24 -> "\"<\" expected"
			25 -> "\"^\" expected"
			26 -> "\"out\" expected"
			27 -> "\">\" expected"
			28 -> "\",\" expected"
			29 -> "\"<.\" expected"
			30 -> "\".>\" expected"
			31 -> "\"[\" expected"
			32 -> "\"]\" expected"
			33 -> "\"|\" expected"
			34 -> "\"WEAK\" expected"
			35 -> "\"(\" expected"
			36 -> "\")\" expected"
			37 -> "\"{\" expected"
			38 -> "\"}\" expected"
			39 -> "\"SYNC\" expected"
			40 -> "\"IF\" expected"
			41 -> "\"CONTEXT\" expected"
			42 -> "\"(.\" expected"
			43 -> "\".)\" expected"
			44 -> "??? expected"
			45 -> "this symbol not expected in Coco"
			46 -> "this symbol not expected in TokenDecl"
			47 -> "invalid TokenDecl"
			48 -> "invalid AttrDecl"
			49 -> "invalid AttrDecl"
			50 -> "invalid AttrDecl"
			51 -> "invalid AttrDecl"
			52 -> "invalid AttrDecl"
			53 -> "invalid SimSet"
			54 -> "invalid Sym"
			55 -> "invalid Term"
			56 -> "invalid Factor"
			57 -> "invalid Attribs"
			58 -> "invalid Attribs"
			59 -> "invalid Attribs"
			60 -> "invalid Attribs"
			61 -> "invalid Attribs"
			62 -> "invalid TokenFactor"
			63 -> "invalid Bracketed"
			else -> "error $n"
		}
		printMsg(line, col, s);
		count++;
	}

	fun SemErr (line: Int, col: Int, s: String) {
		printMsg(line, col, s)
		count++
	}
	
	fun SemErr (s: String) {
		errorStream.println(s)
		count++
	}
	
	fun Warning (line: Int, col: Int, s: String) {
		printMsg(line, col, s)
	}
	
	fun Warning (s: String) {
		errorStream.println(s)
	}
} // Errors


class FatalError(s: String) : RuntimeException(s)
