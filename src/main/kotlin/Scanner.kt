/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from C# to Java by Wolfgang Ahorner
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
package coco;

import java.io.IOException
import java.io.InputStream
import java.io.RandomAccessFile
import kotlin.math.min

class Token {
    var kind: Int = 0           // token kind
    var pos: Int = 0            // token position in bytes in the source text (starting at 0)
    var charPos: Int = 0        // token position in characters in the source text (starting at 0)
    var col: Int = 0            // token column (starting at 1)
    var line: Int = 0           // token line (starting at 1)
    var `val`: String = ""      // token value
    var next: Token? = null     // ML 2005-03-11 Peek tokens are kept in linked list
}

//-----------------------------------------------------------------------------------
// Buffer
//-----------------------------------------------------------------------------------
open class Buffer {
    private var buf: ByteArray      // input buffer
    private var bufStart = 0        // position of first byte in buffer relative to input stream
    private var bufLen = 0          // length of buffer
    private var fileLen = 0         // length of input stream (may change if stream is no file)
    private var bufPos = 0          // current position in buffer
    private var file: RandomAccessFile? = null  // input stream (seekable)
    private var stream: InputStream? = null     // growing input stream (e.g.: console, network)

    constructor(s: InputStream?) {
        stream = s
        bufPos = 0
        bufStart = bufPos
        bufLen = bufStart
        fileLen = bufLen
        buf = ByteArray(MIN_BUFFER_LENGTH)
    }

    constructor(fileName: String?) {
        try {
            file = RandomAccessFile(fileName, "r")
            fileLen = file!!.length().toInt()
            bufLen = min(fileLen, MAX_BUFFER_LENGTH)
            buf = ByteArray(bufLen)
            bufStart = Int.Companion.MAX_VALUE // nothing in buffer so far
            if (fileLen > 0) this.pos = 0 // setup buffer to position 0 (start)
            else bufPos = 0 // index 0 is already after the file, thus setPos(0) is invalid

            if (bufLen == fileLen) Close()
        } catch (e: IOException) {
            throw FatalError("Could not open file " + fileName)
        }
    }

    // don't use b after this call anymore
    // called in UTF8Buffer constructor
    protected constructor(b: Buffer) {
        buf = b.buf
        bufStart = b.bufStart
        bufLen = b.bufLen
        fileLen = b.fileLen
        bufPos = b.bufPos
        file = b.file
        stream = b.stream
        // keep finalize from closing the file
        b.file = null
    }

    fun Close() {
        if (file != null) {
            try {
                file!!.close()
                file = null
            } catch (e: IOException) {
                throw FatalError(e.message!!)
            }
        }
    }

    open fun Read(): Int {
        if (bufPos < bufLen) {
            return buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else if (this.pos < fileLen) {
            this.pos = this.pos // shift buffer start to pos
            return buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else if (stream != null && ReadNextStreamChunk() > 0) {
            return buf[bufPos++].toInt() and 0xff // mask out sign bits
        } else {
            return EOF
        }
    }

    fun Peek(): Int {
        val curPos = this.pos
        val ch = Read()
        this.pos = curPos
        return ch
    }

    // beg .. begin, zero-based, inclusive, in byte
    // end .. end, zero-based, exclusive, in byte
    fun GetString(beg: Int, end: Int): String {
        var len = 0
        val buf = CharArray(end - beg)
        val oldPos = this.pos
        this.pos = beg
        while (this.pos < end) buf[len++] = Read().toChar()
        this.pos = oldPos
        return String(buf, 0, len)
    }

    var pos: Int
        get() = bufPos + bufStart
        set(value) {
            if (value >= fileLen && stream != null) {
                // Wanted position is after buffer and the stream
                // is not seek-able e.g. network or console,
                // thus we have to read the stream manually till
                // the wanted position is in sight.
                while (value >= fileLen && ReadNextStreamChunk() > 0);
            }

            if (value < 0 || value > fileLen) {
                throw FatalError("buffer out of bounds access, position: " + value)
            }

            if (value >= bufStart && value < bufStart + bufLen) { // already in buffer
                bufPos = value - bufStart
            } else if (file != null) { // must be swapped in
                try {
                    file!!.seek(value.toLong())
                    bufLen = file!!.read(buf)
                    bufStart = value
                    bufPos = 0
                } catch (e: IOException) {
                    throw FatalError(e.message!!)
                }
            } else {
                // set the position to the end of the file, Pos will return fileLen.
                bufPos = fileLen - bufStart
            }
        }

    // Read the next chunk of bytes from the stream, increases the buffer
    // if needed and updates the fields fileLen and bufLen.
    // Returns the number of bytes read.
    private fun ReadNextStreamChunk(): Int {
        var free = buf.size - bufLen
        if (free == 0) {
            // in the case of a growing input stream
            // we can neither seek in the stream, nor can we
            // foresee the maximum length, thus we must adapt
            // the buffer size on demand.
            val newBuf = ByteArray(bufLen * 2)
            System.arraycopy(buf, 0, newBuf, 0, bufLen)
            buf = newBuf
            free = bufLen
        }

        val read: Int
        try {
            read = stream!!.read(buf, bufLen, free)
        } catch (ioex: IOException) {
            throw FatalError(ioex.message!!)
        }

        if (read > 0) {
            bufLen = (bufLen + read)
            fileLen = bufLen
            return read
        }
        // end of stream reached
        return 0
    }

    companion object {
        // This Buffer supports the following cases:
        // 1) seekable stream (file)
        //    a) whole stream in buffer
        //    b) part of stream in buffer
        // 2) non seekable stream (network, console)
        val EOF: Int = Character.MAX_VALUE.code + 1
        private const val MIN_BUFFER_LENGTH = 1024 // 1KB
        private val MAX_BUFFER_LENGTH: Int = MIN_BUFFER_LENGTH * 64 // 64KB
    }
}

//-----------------------------------------------------------------------------------
// UTF8Buffer
//-----------------------------------------------------------------------------------
class UTF8Buffer(b: Buffer) : Buffer(b) {
    override fun Read(): Int {
        var ch: Int
        do {
            ch = super.Read()
            // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
        } while ((ch >= 128) && ((ch and 0xC0) != 0xC0) && (ch != EOF))
        if (ch < 128 || ch == EOF) {
            // nothing to do, first 127 chars are the same in ascii and utf8
            // 0xxxxxxx or end of file character
        } else if ((ch and 0xF0) == 0xF0) {
            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            val c1 = ch and 0x07
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = super.Read()
            val c3 = ch and 0x3F
            ch = super.Read()
            val c4 = ch and 0x3F
            ch = (((((c1 shl 6) or c2) shl 6) or c3) shl 6) or c4
        } else if ((ch and 0xE0) == 0xE0) {
            // 1110xxxx 10xxxxxx 10xxxxxx
            val c1 = ch and 0x0F
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = super.Read()
            val c3 = ch and 0x3F
            ch = (((c1 shl 6) or c2) shl 6) or c3
        } else if ((ch and 0xC0) == 0xC0) {
            // 110xxxxx 10xxxxxx
            val c1 = ch and 0x1F
            ch = super.Read()
            val c2 = ch and 0x3F
            ch = (c1 shl 6) or c2
        }
        return ch
    }
}

//-----------------------------------------------------------------------------------
// StartStates  -- maps characters to start states of tokens
//-----------------------------------------------------------------------------------
class StartStates {
    private class Elem(var key: Int, var `val`: Int) {
        var next: Elem? = null
    }

    private val tab = arrayOfNulls<Elem>(128)

    fun set(key: Int, `val`: Int) {
        val e = Elem(key, `val`)
        val k = key % 128
        e.next = tab[k]
        tab[k] = e
    }

    fun state(key: Int): Int {
        var e = tab[key % 128]
        while (e != null && e.key != key) e = e.next
        return if (e == null) 0 else e.`val`
    }
}

//-----------------------------------------------------------------------------------
// Scanner
//-----------------------------------------------------------------------------------
class Scanner {

	companion object {
        const val EOL: Char = '\n'
        const val eofSym: Int = 0

		const val maxT: Int = 45
		const val noSym: Int = 45


        val start = StartStates()
        val literals: MutableMap<String, Int> = mutableMapOf() // maps literal strings to literal kinds

        init {
			for (i in 65..90) start.set(i, 1)
			for (i in 95..95) start.set(i, 1)
			for (i in 97..122) start.set(i, 1)
			for (i in 48..57) start.set(i, 2)
			start.set(34, 12) 
			start.set(39, 5) 
			start.set(36, 13) 
			start.set(61, 16) 
			start.set(46, 34) 
			start.set(43, 17) 
			start.set(45, 18) 
			start.set(60, 35) 
			start.set(94, 20) 
			start.set(62, 21) 
			start.set(44, 22) 
			start.set(91, 25) 
			start.set(93, 26) 
			start.set(63, 27) 
			start.set(124, 28) 
			start.set(40, 36) 
			start.set(41, 29) 
			start.set(123, 30) 
			start.set(125, 31) 
			start.set(Buffer.EOF, -1)
			literals["COMPILER"] = 6
			literals["IGNORECASE"] = 7
			literals["CHARACTERS"] = 8
			literals["TOKENS"] = 9
			literals["PRAGMAS"] = 10
			literals["COMMENTS"] = 11
			literals["FROM"] = 12
			literals["TO"] = 13
			literals["NESTED"] = 14
			literals["IGNORE"] = 15
			literals["PRODUCTIONS"] = 16
			literals["END"] = 19
			literals["ANY"] = 23
			literals["out"] = 26
			literals["WEAK"] = 35
			literals["SYNC"] = 40
			literals["IF"] = 41
			literals["CONTEXT"] = 42

        }
    }



	var buffer: Buffer      // scanner buffer

    var t: Token? = null    // current token
    var ch: Int = 0         // current input character
    var pos: Int = 0        // byte position of current character
    var charPos: Int = 0    // position by unicode characters starting with 0
    var col: Int = 0        // column number of current character
    var line: Int = 0       // line number of current character
    var oldEols: Int = 0    // EOLs that appeared in a comment;
    var tokens: Token? = null   // list of tokens already peeked (first token is a dummy)
    var pt: Token? = null       // current peek token

    var tval: CharArray = CharArray(16) // token text used in NextToken(), dynamically enlarged
    var tlen: Int = 0 // length of current token
	
	constructor(fileName: String?) {
        buffer = Buffer(fileName)
        Init()
    }

    constructor(s: InputStream?) {
        buffer = Buffer(s)
        Init()
    }

    fun Init() {
        pos = -1
        line = 1
        col = 0
        charPos = -1
        oldEols = 0
        NextCh()
        if (ch == 0xEF) { // check optional byte order mark for UTF-8
            NextCh()
            val ch1 = ch
            NextCh()
            val ch2 = ch
            if (ch1 != 0xBB || ch2 != 0xBF) {
                throw FatalError("Illegal byte order mark at start of file")
            }
            buffer = UTF8Buffer(buffer)
            col = 0
            charPos = -1
            NextCh()
        }
        tokens = Token()
        pt = tokens // first token is a dummy
    }
	
	fun NextCh() {
        if (oldEols > 0) {
            ch = EOL.code
            oldEols--
        } else {
            pos = buffer.pos
            // buffer reads unicode chars, if UTF8 has been detected
            ch = buffer.Read()
            col++
            charPos++
            // replace isolated '\r' by '\n' in order to make
            // eol handling uniform across Windows, Unix and Mac
            if (ch == '\r'.code && buffer.Peek() != '\n'.code) ch = EOL.code
            if (ch == EOL.code) {
                line++
                col = 0
            }
        }

	}
	
	fun AddCh() {
        if (tlen >= tval.size) {
            val newBuf = CharArray(2 * tval.size)
            System.arraycopy(tval, 0, newBuf, 0, tval.size)
            tval = newBuf
        }
        if (ch != Buffer.EOF) {
			tval[tlen++] = ch.toChar()

			NextCh();
		}

	}
	

	private fun Comment0(): Boolean {
		var level = 1; val pos0 = pos; val line0 = line; val col0 = col; val charPos0 = charPos
		NextCh()
		if (ch == '/'.code) {
			NextCh()
			while (true) {
				if (ch == 10) {
					level--
					if (level == 0) { oldEols = line - line0; NextCh(); return true }
					NextCh()
				} else if (ch == Buffer.EOF) return false
				else NextCh()
			}
		} else {
			buffer.pos = pos0; NextCh(); line = line0; col = col0; charPos = charPos0
		}
		return false
	}

	private fun Comment1(): Boolean {
		var level = 1; val pos0 = pos; val line0 = line; val col0 = col; val charPos0 = charPos
		NextCh()
		if (ch == '*'.code) {
			NextCh()
			while (true) {
				if (ch == '*'.code) {
					NextCh()
					if (ch == '/'.code) {
						level--
						if (level == 0) { oldEols = line - line0; NextCh(); return true }
						NextCh()
					}
				} else if (ch == '/'.code) {
					NextCh()
					if (ch == '*'.code) {
						level++; NextCh()
					}
				} else if (ch == Buffer.EOF) return false
				else NextCh()
			}
		} else {
			buffer.pos = pos0; NextCh(); line = line0; col = col0; charPos = charPos0
		}
		return false
	}


    fun CheckLiteral() {
		val `val` = t!!.`val`

		val kind: Any? = literals.get(`val`)
        if (kind != null) {
            t!!.kind = (kind as Int)
        }
    }

	fun NextToken(): Token {
        while (ch == ' '.code ||
			ch in 9 .. 10 || ch == 13
		) NextCh()
		if (ch == '/'.code && Comment0() ||ch == '/'.code && Comment1()) return NextToken();
        var recKind: Int = noSym
        var recEnd = pos
        t = Token()
        t!!.pos = pos
        t!!.col = col
        t!!.line = line
        t!!.charPos = charPos
        var state: Int = start.state(ch)
        tlen = 0
        AddCh()

        loop@ while (true) {
            when (state) {
                -1 -> {
                    t!!.kind = eofSym
                    break@loop
                } // NextCh already done
                0 -> {
                    if (recKind != noSym) {
                        tlen = recEnd - t!!.pos
                        SetScannerBehindT()
                    }
                    t!!.kind = recKind
                    break@loop
                } // NextCh already done
				1 -> {
					recEnd = pos; recKind = 1
					if (ch in '0'.code .. '9'.code || ch in 'A'.code .. 'Z'.code || ch == '_'.code || ch in 'a'.code .. 'z'.code) {AddCh(); state = 1 }
					else {
						t!!.kind = 1; t!!.`val` = String(tval, 0, tlen); CheckLiteral(); return t!!
					}
				}
				2 -> {
					recEnd = pos; recKind = 2
					if (ch in '0'.code .. '9'.code) {AddCh(); state = 2 }
					else {
						t!!.kind = 2; break@loop
					}
				}
				3 -> {
					t!!.kind = 3; break@loop
				}
				4 -> {
					t!!.kind = 4; break@loop
				}
				5 -> {
					if (ch <= 9 || ch in 11 .. 12 || ch in 14 .. '&'.code || ch in '('.code .. '['.code || ch in ']'.code .. 65535) {AddCh(); state = 6 }
					else if (ch == 92) {AddCh(); state = 7 }
					else {
						state = 0
					}
				}
				6 -> {
					if (ch == 39) {AddCh(); state = 9 }
					else {
						state = 0
					}
				}
				7 -> {
					if (ch in ' '.code .. '~'.code) {AddCh(); state = 8 }
					else {
						state = 0
					}
				}
				8 -> {
					if (ch in '0'.code .. '9'.code || ch in 'a'.code .. 'f'.code) {AddCh(); state = 8 }
					else if (ch == 39) {AddCh(); state = 9 }
					else {
						state = 0
					}
				}
				9 -> {
					t!!.kind = 5; break@loop
				}
				10 -> {
					recEnd = pos; recKind = 46
					if (ch in '0'.code .. '9'.code || ch in 'A'.code .. 'Z'.code || ch == '_'.code || ch in 'a'.code .. 'z'.code) {AddCh(); state = 10 }
					else {
						t!!.kind = 46; break@loop
					}
				}
				11 -> {
					recEnd = pos; recKind = 47
					if (ch in '-'.code .. '.'.code || ch in '0'.code .. ':'.code || ch in 'A'.code .. 'Z'.code || ch == '_'.code || ch in 'a'.code .. 'z'.code) {AddCh(); state = 11 }
					else {
						t!!.kind = 47; break@loop
					}
				}
				12 -> {
					if (ch <= 9 || ch in 11 .. 12 || ch in 14 .. '!'.code || ch in '#'.code .. '['.code || ch in ']'.code .. 65535) {AddCh(); state = 12 }
					else if (ch == 10 || ch == 13) {AddCh(); state = 4 }
					else if (ch == '"'.code) {AddCh(); state = 3 }
					else if (ch == 92) {AddCh(); state = 14 }
					else {
						state = 0
					}
				}
				13 -> {
					recEnd = pos; recKind = 46
					if (ch in '0'.code .. '9'.code) {AddCh(); state = 10 }
					else if (ch in 'A'.code .. 'Z'.code || ch == '_'.code || ch in 'a'.code .. 'z'.code) {AddCh(); state = 15 }
					else {
						t!!.kind = 46; break@loop
					}
				}
				14 -> {
					if (ch in ' '.code .. '~'.code) {AddCh(); state = 12 }
					else {
						state = 0
					}
				}
				15 -> {
					recEnd = pos; recKind = 46
					if (ch in '0'.code .. '9'.code) {AddCh(); state = 10 }
					else if (ch in 'A'.code .. 'Z'.code || ch == '_'.code || ch in 'a'.code .. 'z'.code) {AddCh(); state = 15 }
					else if (ch == '='.code) {AddCh(); state = 11 }
					else {
						t!!.kind = 46; break@loop
					}
				}
				16 -> {
					t!!.kind = 17; break@loop
				}
				17 -> {
					t!!.kind = 20; break@loop
				}
				18 -> {
					t!!.kind = 21; break@loop
				}
				19 -> {
					t!!.kind = 22; break@loop
				}
				20 -> {
					t!!.kind = 25; break@loop
				}
				21 -> {
					t!!.kind = 27; break@loop
				}
				22 -> {
					t!!.kind = 28; break@loop
				}
				23 -> {
					t!!.kind = 29; break@loop
				}
				24 -> {
					t!!.kind = 30; break@loop
				}
				25 -> {
					t!!.kind = 31; break@loop
				}
				26 -> {
					t!!.kind = 32; break@loop
				}
				27 -> {
					t!!.kind = 33; break@loop
				}
				28 -> {
					t!!.kind = 34; break@loop
				}
				29 -> {
					t!!.kind = 37; break@loop
				}
				30 -> {
					t!!.kind = 38; break@loop
				}
				31 -> {
					t!!.kind = 39; break@loop
				}
				32 -> {
					t!!.kind = 43; break@loop
				}
				33 -> {
					t!!.kind = 44; break@loop
				}
				34 -> {
					recEnd = pos; recKind = 18
					if (ch == '.'.code) {AddCh(); state = 19 }
					else if (ch == '>'.code) {AddCh(); state = 24 }
					else if (ch == ')'.code) {AddCh(); state = 33 }
					else {
						t!!.kind = 18; break@loop
					}
				}
				35 -> {
					recEnd = pos; recKind = 24
					if (ch == '.'.code) {AddCh(); state = 23 }
					else {
						t!!.kind = 24; break@loop
					}
				}
				36 -> {
					recEnd = pos; recKind = 36
					if (ch == '.'.code) {AddCh(); state = 32 }
					else {
						t!!.kind = 36; break@loop
					}
				}

			}
		}
		t!!.`val` = String(tval, 0, tlen)
        return t!!
	}
	
    private fun SetScannerBehindT() {
        buffer.pos = t!!.pos
        NextCh()
        line = t!!.line
        col = t!!.col
        charPos = t!!.charPos
        for (i in 0..<tlen) NextCh()
    }

    // get the next token (possibly a token already seen during peeking)
    fun Scan(): Token {
        if (tokens!!.next == null) {
            return NextToken()
        } else {
            tokens = tokens!!.next
            pt = tokens
            return tokens!!
        }
    }

    // get the next token, ignore pragmas
    fun Peek(): Token {
        do {
            if (pt!!.next == null) {
                pt!!.next = NextToken()
            }
            pt = pt!!.next
        } while (pt!!.kind > maxT) // skip pragmas

        return pt!!
    }

    // make sure that peeking starts at current scan position
    fun ResetPeek() {
        pt = tokens
    }

} // end Scanner
